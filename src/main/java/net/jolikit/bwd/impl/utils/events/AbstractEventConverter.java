/*
 * Copyright 2019-2021 Jeff Hain
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package net.jolikit.bwd.impl.utils.events;

import net.jolikit.bwd.api.events.BwdEventType;
import net.jolikit.bwd.api.events.BwdKeyEventPr;
import net.jolikit.bwd.api.events.BwdKeyEventT;
import net.jolikit.bwd.api.events.BwdMouseEvent;
import net.jolikit.bwd.api.events.BwdWheelEvent;
import net.jolikit.bwd.api.graphics.GPoint;
import net.jolikit.bwd.api.graphics.GRect;
import net.jolikit.bwd.impl.utils.basics.InterfaceBwdHostImpl;
import net.jolikit.bwd.impl.utils.basics.ScaleHelper;
import net.jolikit.lang.LangUtils;
import net.jolikit.lang.NbrsUtils;

/**
 * Abstract class to make it easier to create BWD events from corresponding
 * backing events, in particular when these don't provide all the required
 * information.
 * 
 * Must use one instance per host, for it stores host-specific state.
 */
public abstract class AbstractEventConverter {

    //--------------------------------------------------------------------------
    // FIELDS
    //--------------------------------------------------------------------------
    
    private final CmnInputConvState commonState;
    
    private final InterfaceBwdHostImpl host;
    
    private final ScaleHelper scaleHelper;
    
    //--------------------------------------------------------------------------
    // PUBLIC METHODS
    //--------------------------------------------------------------------------
    
    public AbstractEventConverter(
        CmnInputConvState commonState,
        InterfaceBwdHostImpl host,
        ScaleHelper scaleHelper) {
        this.commonState = LangUtils.requireNonNull(commonState);
        this.host = LangUtils.requireNonNull(host);
        this.scaleHelper = LangUtils.requireNonNull(scaleHelper);
    }
    
    /*
     * Key events.
     */
    
    /**
     * The "isRepeat" boolean of the returned event doesn't matter,
     * repetition being synthesized later by our bindings.
     */
    public BwdKeyEventPr newKeyPressedEvent(Object backingEvent) {
        
        this.updateFromBackingEvent(backingEvent);
        
        final boolean isRepeat = false;
        return new BwdKeyEventPr(
                this.host,
                BwdEventType.KEY_PRESSED,
                //
                this.getKey(backingEvent),
                this.getKeyLocation(backingEvent),
                isRepeat,
                //
                this.commonState.getModifierKeyDownSet());
    }
    
    public BwdKeyEventPr newKeyReleasedEvent(Object backingEvent) {
        
        this.updateFromBackingEvent(backingEvent);
        
        final boolean isRepeat = false;
        return new BwdKeyEventPr(
                this.host,
                BwdEventType.KEY_RELEASED,
                //
                this.getKey(backingEvent),
                this.getKeyLocation(backingEvent),
                isRepeat,
                //
                this.commonState.getModifierKeyDownSet());
    }
    
    /**
     * The "isRepeat" boolean of the returned event doesn't matter,
     * repetition being synthesized later by our bindings.
     */
    public BwdKeyEventT newKeyTypedEventElseNull(Object backingEvent) {
        
        this.updateFromBackingEvent(backingEvent);
        
        final int codePoint = this.getCodePoint(backingEvent);
        if (codePoint == 0) {
            // Code point 0 not allowed.
            return null;
        }
        
        final boolean isRepeat = false;
        return new BwdKeyEventT(
                this.host,
                //
                codePoint,
                isRepeat,
                //
                this.commonState.getModifierKeyDownSet());
    }
    
    /*
     * Mouse events.
     * 
     * No method for mouse clicked or mouse dragged,
     * since these types of events are optional and
     * to be generated by clients from other events.
     */
    
    public BwdMouseEvent newMousePressedEvent(Object backingEvent) {
        return this.newMouseEvent(
                backingEvent,
                BwdEventType.MOUSE_PRESSED);
    }
    
    public BwdMouseEvent newMouseReleasedEvent(Object backingEvent) {
        return this.newMouseEvent(
                backingEvent,
                BwdEventType.MOUSE_RELEASED);
    }
    
    public BwdMouseEvent newMouseEnteredClientEvent(Object backingEvent) {
        return this.newMouseEvent(
                backingEvent,
                BwdEventType.MOUSE_ENTERED_CLIENT);
    }
    
    public BwdMouseEvent newMouseExitedClientEvent(Object backingEvent) {
        return this.newMouseEvent(
                backingEvent,
                BwdEventType.MOUSE_EXITED_CLIENT);
    }
    
    public BwdMouseEvent newMouseMovedEvent(Object backingEvent) {
        return this.newMouseEvent(
                backingEvent,
                BwdEventType.MOUSE_MOVED);
    }
    
    /*
     * Wheel events.
     */
    
    public BwdWheelEvent newWheelEventElseNull(Object backingEvent) {
        
        this.updateFromBackingEvent(backingEvent);
        
        final GPoint posInScreenInOs = this.commonState.getMousePosInScreenInOs();
        final GPoint posInScreenInBd = this.scaleHelper.pointOsToBd(posInScreenInOs);
        final GPoint posInClientInBd = this.computePosInClientInBd(posInScreenInBd);
        
        final int xRoll = this.getWheelXRoll(backingEvent);
        final int yRoll = this.getWheelYRoll(backingEvent);
        if ((xRoll == 0)
                && (yRoll == 0)) {
            /*
             * Some bindings generate wheel events with zero roll amounts.
             * Our spec says wheel events must not have zero roll amounts,
             * so we just ignore them.
             */
            return null;
        }
        
        final GPoint roll = GPoint.valueOf(xRoll, yRoll);
        return new BwdWheelEvent(
            this.host,
            posInScreenInBd,
            posInClientInBd,
            roll,
            this.commonState.getModifierKeyDownSet());
    }
    
    //--------------------------------------------------------------------------
    // PROTECTED METHODS
    //--------------------------------------------------------------------------
    
    /**
     * Called at the start of each event conversion.
     * Must update all possible internal values (*), which are then used
     * for conversion of current and later event(s).
     * 
     * (*) Except num/caps/scroll locks states, which might not be computable
     * from backing event since it might not hold the info whether it's a key
     * press or a release. These locks states are to be computed just before
     * or after call to this method, in case of key press or release.
     */
    protected abstract void updateFromBackingEvent(Object backingEvent);
    
    /*
     * Key events.
     */
    
    /**
     * @see #BwdKeys
     * 
     * @return The key corresponding to the backing key, doing best effort.
     */
    protected abstract int getKey(Object backingEvent);

    /**
     * @see #BwdKeyLocations
     * 
     * @return The corresponding key location.
     */
    protected abstract int getKeyLocation(Object backingEvent);

    /**
     * @return The corresponding code point,
     *         or NUL character (0) if none.
     */
    protected abstract int getCodePoint(Object backingEvent);
    
    /*
     * Mouse events.
     */
    
    /**
     * @return The button for mouse pressed/released events,
     *         or BwdMouseButtons.NO_STATEMENT.
     */
    protected abstract int getButton(Object backingEvent);
    
    /*
     * Wheel events.
     */
    
    protected abstract int getWheelXRoll(Object backingEvent);
    
    protected abstract int getWheelYRoll(Object backingEvent);

    /*
     * 
     */
    
    protected CmnInputConvState getCommonState() {
        return this.commonState;
    }
    
    protected InterfaceBwdHostImpl getHost() {
        return this.host;
    }
    
    protected GPoint computePosInClientInBd(GPoint posInScreenInBd) {
        final InterfaceBwdHostImpl host = this.getHost();
        final GRect clientBoundsInOs = host.getClientBoundsInOs();
        final GPoint posInClientInBd;
        if (!clientBoundsInOs.isEmpty()) {
            final GRect scaledClientBoundsInBd =
                this.scaleHelper.rectOsToBdContained(
                    clientBoundsInOs);
            /*
             * Ensuring that position in client frame stays in client bounds.
             * Could leak out due to backing libraries glitches (such as SDL2 on Mac),
             * or due to position being over the padding insets around scaled client.
             */
            final int xInClientInBd = NbrsUtils.toRange(
                0, scaledClientBoundsInBd.xSpan() - 1,
                posInScreenInBd.x() - scaledClientBoundsInBd.x());
            final int yInClientInBd = NbrsUtils.toRange(
                0, scaledClientBoundsInBd.ySpan() - 1,
                posInScreenInBd.y() - scaledClientBoundsInBd.y());
            posInClientInBd = GPoint.valueOf(
                xInClientInBd,
                yInClientInBd);
        } else {
            posInClientInBd = GPoint.ZERO;
        }
        return posInClientInBd;
    }
    
    //--------------------------------------------------------------------------
    // PRIVATE METHODS
    //--------------------------------------------------------------------------
    
    /**
     * MOUSE_CLICKED events are not to be generated by bindings.
     * MOUSE_DRAGGED events can be created from MOUSE_MOVED events,
     * using event.asMouseDraggedEvent().
     */
    private BwdMouseEvent newMouseEvent(
            Object backingEvent,
            BwdEventType eventType) {
        
        this.updateFromBackingEvent(backingEvent);
        
        final GPoint posInScreenInOs = this.commonState.getMousePosInScreenInOs();
        final GPoint posInScreenInBd = this.scaleHelper.pointOsToBd(posInScreenInOs);
        final GPoint posInClientInBd = this.computePosInClientInBd(posInScreenInBd);
        
        return new BwdMouseEvent(
                this.host,
                eventType,
                posInScreenInBd,
                posInClientInBd,
                this.getButton(backingEvent),
                this.commonState.getButtonDownSet(),
                this.commonState.getModifierKeyDownSet());
    }
}
