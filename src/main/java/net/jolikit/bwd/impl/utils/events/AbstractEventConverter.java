/*
 * Copyright 2019-2020 Jeff Hain
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package net.jolikit.bwd.impl.utils.events;

import net.jolikit.bwd.api.InterfaceBwdHost;
import net.jolikit.bwd.api.events.BwdEventType;
import net.jolikit.bwd.api.events.BwdKeyEventPr;
import net.jolikit.bwd.api.events.BwdKeyEventT;
import net.jolikit.bwd.api.events.BwdMouseEvent;
import net.jolikit.bwd.api.events.BwdWheelEvent;
import net.jolikit.bwd.api.graphics.GPoint;
import net.jolikit.lang.LangUtils;

/**
 * Abstract class to make it easier to create BWD events from corresponding
 * backing events, in particular when these don't provide all the required
 * information.
 * 
 * Must use one instance per host, for it stores host-specific state.
 */
public abstract class AbstractEventConverter {

    //--------------------------------------------------------------------------
    // FIELDS
    //--------------------------------------------------------------------------
    
    private final CmnInputConvState commonState;
    
    private final InterfaceBwdHost host;
    
    private GPoint mousePosInClient = GPoint.ZERO;

    //--------------------------------------------------------------------------
    // PUBLIC METHODS
    //--------------------------------------------------------------------------
    
    public AbstractEventConverter(
            CmnInputConvState commonState,
            InterfaceBwdHost host) {
        this.commonState = LangUtils.requireNonNull(commonState);
        this.host = LangUtils.requireNonNull(host);
    }
    
    /*
     * Key events.
     */
    
    /**
     * The "isRepeat" boolean of the returned event doesn't matter,
     * repetition being synthesized later by our bindings.
     */
    public BwdKeyEventPr newKeyPressedEvent(Object backingEvent) {
        
        this.updateFromBackingEvent(backingEvent);
        
        final boolean isRepeat = false;
        return new BwdKeyEventPr(
                this.host,
                BwdEventType.KEY_PRESSED,
                //
                this.getKey(backingEvent),
                this.getKeyLocation(backingEvent),
                isRepeat,
                //
                this.commonState.getModifierKeyDownSet());
    }
    
    public BwdKeyEventPr newKeyReleasedEvent(Object backingEvent) {
        
        this.updateFromBackingEvent(backingEvent);
        
        final boolean isRepeat = false;
        return new BwdKeyEventPr(
                this.host,
                BwdEventType.KEY_RELEASED,
                //
                this.getKey(backingEvent),
                this.getKeyLocation(backingEvent),
                isRepeat,
                //
                this.commonState.getModifierKeyDownSet());
    }
    
    /**
     * The "isRepeat" boolean of the returned event doesn't matter,
     * repetition being synthesized later by our bindings.
     */
    public BwdKeyEventT newKeyTypedEventElseNull(Object backingEvent) {
        
        this.updateFromBackingEvent(backingEvent);
        
        final int codePoint = this.getCodePoint(backingEvent);
        if (codePoint == 0) {
            // Code point 0 not allowed.
            return null;
        }
        
        final boolean isRepeat = false;
        return new BwdKeyEventT(
                this.host,
                //
                codePoint,
                isRepeat,
                //
                this.commonState.getModifierKeyDownSet());
    }
    
    /*
     * Mouse events.
     * 
     * No method for mouse clicked or mouse dragged,
     * since these types of events are optional and
     * to be generated by clients from other events.
     */
    
    public BwdMouseEvent newMousePressedEvent(Object backingEvent) {
        return this.newMouseEvent(
                backingEvent,
                BwdEventType.MOUSE_PRESSED);
    }
    
    public BwdMouseEvent newMouseReleasedEvent(Object backingEvent) {
        return this.newMouseEvent(
                backingEvent,
                BwdEventType.MOUSE_RELEASED);
    }
    
    public BwdMouseEvent newMouseEnteredClientEvent(Object backingEvent) {
        return this.newMouseEvent(
                backingEvent,
                BwdEventType.MOUSE_ENTERED_CLIENT);
    }
    
    public BwdMouseEvent newMouseExitedClientEvent(Object backingEvent) {
        return this.newMouseEvent(
                backingEvent,
                BwdEventType.MOUSE_EXITED_CLIENT);
    }
    
    public BwdMouseEvent newMouseMovedEvent(Object backingEvent) {
        return this.newMouseEvent(
                backingEvent,
                BwdEventType.MOUSE_MOVED);
    }
    
    /*
     * Wheel events.
     */
    
    public BwdWheelEvent newWheelEventElseNull(Object backingEvent) {
        
        this.updateFromBackingEvent(backingEvent);
        
        final GPoint posInScreen = this.commonState.getMousePosInScreen();
        final GPoint posInClient = this.getMousePosInClient();
        
        final int xRoll = this.getWheelXRoll(backingEvent);
        final int yRoll = this.getWheelYRoll(backingEvent);
        if ((xRoll == 0)
                && (yRoll == 0)) {
            /*
             * Some bindings generate wheel events with zero roll amounts.
             * Our spec says wheel events must not have zero roll amounts,
             * so we just ignore them.
             */
            return null;
        }

        return new BwdWheelEvent(
                this.host,
                //
                posInScreen.x(),
                posInScreen.y(),
                posInClient.x(),
                posInClient.y(),
                //
                xRoll,
                yRoll,
                //
                this.commonState.getModifierKeyDownSet());
    }
    
    //--------------------------------------------------------------------------
    // PROTECTED METHODS
    //--------------------------------------------------------------------------
    
    /**
     * Called at the start of each event conversion.
     * Must update all possible internal values (*), which are then used
     * for conversion of current and later event(s).
     * 
     * (*) Except num/caps/scroll locks states, which might not be computable
     * from backing event since it might not hold the info whether it's a key
     * press or a release. These locks states are to be computed just before
     * or after call to this method, in case of key press or release.
     */
    protected abstract void updateFromBackingEvent(Object backingEvent);
    
    /*
     * Key events.
     */
    
    /**
     * @see #BwdKeys
     * 
     * @return The key corresponding to the backing key, doing best effort.
     */
    protected abstract int getKey(Object backingEvent);

    /**
     * @see #BwdKeyLocations
     * 
     * @return The corresponding key location.
     */
    protected abstract int getKeyLocation(Object backingEvent);

    /**
     * @return The corresponding code point,
     *         or NUL character (0) if none.
     */
    protected abstract int getCodePoint(Object backingEvent);
    
    /*
     * Mouse events.
     */
    
    /**
     * @return The button for mouse pressed/released events,
     *         or BwdMouseButtons.NO_STATEMENT.
     */
    protected abstract int getButton(Object backingEvent);
    
    /*
     * Wheel events.
     */
    
    protected abstract int getWheelXRoll(Object backingEvent);
    
    protected abstract int getWheelYRoll(Object backingEvent);

    /*
     * 
     */
    
    protected CmnInputConvState getCommonState() {
        return this.commonState;
    }
    
    protected InterfaceBwdHost getHost() {
        return this.host;
    }

    protected GPoint getMousePosInClient() {
        return this.mousePosInClient;
    }

    protected void setMousePosInClient(GPoint mousePosInClient) {
        this.mousePosInClient = mousePosInClient;
    }
    
    //--------------------------------------------------------------------------
    // PRIVATE METHODS
    //--------------------------------------------------------------------------
    
    /**
     * MOUSE_CLICKED events are not to be generated by bindings.
     * MOUSE_DRAGGED events can be created from MOUSE_MOVED events,
     * using event.asMouseDraggedEvent().
     */
    private BwdMouseEvent newMouseEvent(
            Object backingEvent,
            BwdEventType eventType) {
        
        this.updateFromBackingEvent(backingEvent);
        
        final GPoint posInScreen = this.commonState.getMousePosInScreen();
        final GPoint posInClient = this.getMousePosInClient();
        
        return new BwdMouseEvent(
                this.host,
                eventType,
                //
                posInScreen.x(),
                posInScreen.y(),
                posInClient.x(),
                posInClient.y(),
                //
                this.getButton(backingEvent),
                //
                this.commonState.getButtonDownSet(),
                //
                this.commonState.getModifierKeyDownSet());
    }
}
