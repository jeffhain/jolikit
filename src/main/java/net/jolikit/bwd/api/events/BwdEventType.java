/*
 * Copyright 2019 Jeff Hain
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package net.jolikit.bwd.api.events;

import java.util.Arrays;
import java.util.List;

/**
 * Window events:
 * These events might be generated by the backing library or by the binding,
 * but also, unlike the other events, programmatically, typically following
 * calls to host API, so beware of infinite loops with your listeners.
 * 
 * Mouse enter/exit:
 * On mouse dragged, some libraries, such as AWT/Swing/JavaFX/SDL2,
 * generate mouse exited/entered events when the mouse actually enters or
 * exits the client area, and others, like SWT/LWJGL3/JOGL/Qt4/Allegro5,
 * generate these events only after the drag button is released.
 * To keep binding implementations simple and be versatile, we allow for
 * either of these behaviors, so if you want homogeneity you should try
 * not to rely on one of these behaviors in particular.
 * 
 * Key repetition:
 * When a key is held down, some libraries, such as LWJGL3/Allegro5,
 * just generate repeated key typed events; others, such as AWT/Swing/JavaFX,
 * also generate repeated key pressed events, and others, such as
 * SWT/JOGL/Qt4/SDL2/(*), just have a single event for both key pressed and
 * key typed, and so they just repeat this event.
 * [(*) LWJGL3 is part of these for keys like TAB or ESCAPE, for which
 * no key typed event is generated, so we must generate them from
 * the corresponding key pressed event.]
 * Also, some libraries, such as AWT/Swing/JavaFX/SWT/LWJGL3, don't indicate
 * whether a key pressed/typed event is a repetition.
 * Also, it's possible that some libraries would just not generate any
 * repeated event for keys held down, and users might want to configure
 * the speed of the repetition.
 * Also, some libraries, such as SDL2, generate synthetic key released
 * events just before focus loss, and most of them generate synthetic
 * key pressed events just after focus gain if some keys are already
 * down.
 * What we do:
 * Firstly, we want for bindings to generate repetitions for key typed
 * events, for it's both a nice feature, and doable even if the backing
 * library doesn't generate repeated events.
 * Secondly, to keep things consistent and intuitive, we assume that
 * "key pressed" and "key released" events are more precisely
 * "key has been pressed" and "key has been released" events,
 * not "key is being pressed" and "key is being released" events,
 * which would require repetition of "key released" events for all keys
 * not being pressed, which would be crazy.
 * As a result, bindings must not repeat key pressed events, only key typed
 * events (which should rather be called "character generated" events, but
 * that we call "key typed" events because everyone is used to it).
 * This can be done by ignoring key pressed events for keys already pressed
 * and not yet released, with a proper state cleanup on focus loss (or gain).
 * Thirdly, if keys are held down, we allow for synthetic key pressed or
 * key released events to be generated respectively at focus gain or loss.
 * 
 * Preconditions:
 * Events preconditions apply to the state as observed by each event listener,
 * not to the current state of the host, which can change before events get
 * processed.
 * Preconditions for window events are designed to be intuitive and to minimize
 * the amount of possible states (for example, focus must be lost before hiding
 * or iconification).
 * Since window events, with their tight preconditions, can be used to implement
 * simple and clean life cycle related code, we only use relaxed preconditions
 * for when other events can occur (for example, just not after close), or even
 * whether they are supposed to occur at all (for example, MOUSE_EXITED_CLIENT
 * might not occur on closing), which makes bindings easier to implement.
 * 
 * User events:
 * There is no need for user events at the BWD level, since UI thread scheduler
 * can be used to execute runnables in UI thread, but event listener interface
 * could be extended at a higher level for adding an onUserEvent(Object) method
 * to propagate user events for example through a toolkit's components.
 * 
 * @see #InterfaceBwdEventListener for information about whether and when
 *      each of these events must be generated.
 */
public enum BwdEventType {
    /*
     * Window events.
     */
    /**
     * Precondition: (!showing) && (!closed).
     */
    WINDOW_SHOWN,
    /**
     * Precondition: showing, which implies (!closed).
     */
    WINDOW_HIDDEN,
    /**
     * Precondition: showing && (!iconified) && (!focused), which implies (!closed).
     */
    WINDOW_FOCUS_GAINED,
    /**
     * Precondition: focused, which implies showing && (!iconified), which implies (!closed).
     */
    WINDOW_FOCUS_LOST,
    /**
     * Iconification means the window is still shown, but just as an icon
     * on some desktop or taskbar.
     * (De-)iconification typically doesn't trigger moved/resized events,
     * but it might, for example if iconification can only be implemented
     * by moving the window out of screen, which some libraries do.
     * 
     * Precondition: showing && (!focused) && (!iconified), which implies (!closed).
     */
    WINDOW_ICONIFIED,
    /**
     * Precondition: showing && iconified, which implies (!focused) && (!closed).
     */
    WINDOW_DEICONIFIED,
    /**
     * Precondition: showing && (!iconified) && (!maximized), which implies (!closed).
     */
    WINDOW_MAXIMIZED,
    /**
     * Precondition: showing && (!iconified) && maximized, which implies (!closed).
     */
    WINDOW_DEMAXIMIZED,
    /**
     * Must be generated after host's (x,y) changed, possibly with some delay,
     * and therefore possibly without actual change since last call.
     * 
     * We allow for this event to be fired when maximized, not to nitpick too much,
     * and because it would be appropriate in case of dynamic screen bounds.
     * 
     * Precondition: showing && (!iconified), which implies (!closed).
     */
    WINDOW_MOVED,
    /**
     * Must be generated after host's (width,height) changed, possibly with
     * some delay, and therefore possibly without actual change since last call.
     * 
     * In case of move with resize, these events should be generated after
     * the corresponding WINDOW_MOVED event, but we don't require it, for it
     * might be hard to implement, especially in case  of events buffering
     * to avoid spam.
     * 
     * We allow for this event to be fired when maximized, not to nitpick too much,
     * and because it would be appropriate in case of dynamic screen bounds.
     * 
     * JavaFX/SWT/JOGL/LWJGL3/Qt4/Allegro5/SDL2 generate move before resize,
     * AWT/Swing do the opposite.
     * 
     * Precondition: showing && (!iconified), which implies (!closed).
     */
    WINDOW_RESIZED,
    /**
     * Must be generated when the host has been closed, which means at the end
     * of its close() method or just after it completed.
     * 
     * Note that when this even occurs, all corresponding backing library
     * resources might not have been released, for example if the backing
     * library has no "host closed" event but only a "host closing" event.
     * 
     * This event occurs at most once for a same host
     * (other than due to eventual bad threading usage).
     * 
     * Not providing a way to prevent host closing, as depending on
     * implementation it might not be possible.
     * 
     * Precondition: (!showing) && (!focused) && (!closed).
     */
    WINDOW_CLOSED,
    /*
     * Key events.
     */
    /**
     * Must be generated, once, each time a key gets pressed.
     * 
     * Note that some libraries don't generate events for some special keys,
     * such as PrintScreen.
     * 
     * Multiple presses can happen for a same key without intermediary releases,
     * for example if window looses focus in-between.
     * 
     * Precondition: (!closed).
     */
    KEY_PRESSED,
    /**
     * Must be generated when a character is generated,
     * typically due to a key or combination of keys being pressed.
     * 
     * Can be repeated if keys are held down, and for this reason
     * alone it must take place between between corresponding
     * key pressed and key released events.
     * Note that it's therefore not homogeneous with mouse
     * pressed/released/clicked events, which always occur in this order.
     * 
     * Precondition: (!closed).
     */
    KEY_TYPED,
    /**
     * Must be generated, once, each time a key gets released.
     * 
     * Multiple releases can happen for a same key without intermediary presses,
     * for example if window looses focus in-between.
     * 
     * Precondition: (!closed).
     */
    KEY_RELEASED,
    /*
     * Mouse events.
     */
    /**
     * Must be generated when a mouse button (first, middle, or secondary)
     * has been pressed, possibly only when the mouse is inside the
     * client area, due to some libraries not generating such events when
     * the mouse is outside of it.
     * Also, due to what can happen when the mouse is outside the client
     * or focus is lost, even for a same host and mouse button,
     * multiple mouse pressed events might not be separated
     * by corresponding mouse released events.
     * 
     * Precondition: (!closed).
     */
    MOUSE_PRESSED,
    /**
     * Must be generated when a mouse button (first, middle, or secondary)
     * has been released, possibly only when the mouse is inside the
     * client area, due to some libraries not generating such events when
     * the mouse is outside.
     * Also, due to what can happen when mouse is outside client
     * or focus is lost, even for a same host and mouse button,
     * multiple mouse released events might not be separated
     * by corresponding mouse pressed events.
     * 
     * Precondition: (!closed).
     */
    MOUSE_RELEASED,
    /**
     * This event is special, as it must not be generated by the binding,
     * but, if ever, by a higher level layer, such as a toolkit,
     * depending on which "component" the mouse was at press
     * and release time.
     * We still define this type here, for high level layers
     * to be able to use this type for it.
     * 
     * Must be generated, if ever, on the client side, after mouse released
     * events, when proper conditions are fulfilled, typically (as some
     * libraries do) if the mouse was released exactly at the same location
     * it was pressed at, or if it was released over the same "component".
     * 
     * Precondition: (!closed).
     */
    MOUSE_CLICKED,
    /**
     * Must be generated when mouse entered the client, either due to
     * movement of the mouse, or due to movement, state or focus change of
     * the host, and before any other mouse event in client.
     * 
     * Precondition: (!closed).
     */
    MOUSE_ENTERED_CLIENT,
    /**
     * Must be generated when mouse exited the client, either due to
     * movement of the mouse, or to movement, state or focus change of
     * the host, and before any other mouse event outside client.
     * 
     * Precondition: (!closed).
     */
    MOUSE_EXITED_CLIENT,
    /**
     * Must be generated by focused hosts when the mouse is being moved
     * and drag button is not down, possibly only when the mouse is inside
     * the client area, due to some libraries not generating such events
     * when the mouse is outside.
     * 
     * Precondition: (!closed).
     */
    MOUSE_MOVED,
    /**
     * Similar to MOUSE_MOVED, but only generated when drag button is down.
     * 
     * Precondition: (!closed).
     */
    MOUSE_DRAGGED,
    /*
     * Wheel event.
     */
    /**
     * Must be generated when the wheel, or mouse wheel if there is one,
     * is rolled, or when an equivalent scroll-like gesture is done.
     * 
     * Precondition: (!closed).
     */
    WHEEL_ROLLED;
    
    /*
     * 
     */
    
    private static final List<BwdEventType> LIST = Arrays.asList(BwdEventType.values());
    
    /**
     * @return An unmodifiable list of enum values, with ordinal as index.
     */
    public static List<BwdEventType> valueList() {
        return LIST;
    }
    
    /*
     * 
     */
    
    public boolean isWindowEventType() {
        return (this.ordinal() >= BwdEventType.WINDOW_SHOWN.ordinal())
                && (this.ordinal() <= BwdEventType.WINDOW_CLOSED.ordinal());
    }
    
    public boolean isKeyEventType() {
        return (this.ordinal() >= BwdEventType.KEY_PRESSED.ordinal())
                && (this.ordinal() <= BwdEventType.KEY_RELEASED.ordinal());
    }
    
    public boolean isMouseEventType() {
        return (this.ordinal() >= BwdEventType.MOUSE_PRESSED.ordinal())
                && (this.ordinal() <= BwdEventType.MOUSE_DRAGGED.ordinal());
    }
    
    public boolean isWheelEventType() {
        return (this.ordinal() == BwdEventType.WHEEL_ROLLED.ordinal());
    }
    
    /*
     * 
     */
    
    /**
     * @return The opposite event type (ex.: HIDDEN for SHOWN), or null if none.
     */
    public BwdEventType opposite() {
        switch (this) {
        /*
         * Window events.
         */
        case WINDOW_SHOWN : return BwdEventType.WINDOW_HIDDEN;
        case WINDOW_HIDDEN : return BwdEventType.WINDOW_SHOWN;
        //
        case WINDOW_FOCUS_GAINED : return BwdEventType.WINDOW_FOCUS_LOST;
        case WINDOW_FOCUS_LOST : return BwdEventType.WINDOW_FOCUS_GAINED;
        //
        case WINDOW_ICONIFIED : return BwdEventType.WINDOW_DEICONIFIED;
        case WINDOW_DEICONIFIED : return BwdEventType.WINDOW_ICONIFIED;
        //
        case WINDOW_MAXIMIZED : return BwdEventType.WINDOW_DEMAXIMIZED;
        case WINDOW_DEMAXIMIZED : return BwdEventType.WINDOW_MAXIMIZED;
        /*
         * Key events.
         */
        case KEY_PRESSED : return BwdEventType.KEY_RELEASED;
        case KEY_RELEASED : return BwdEventType.KEY_PRESSED;
        /*
         * Mouse events.
         */
        case MOUSE_PRESSED : return BwdEventType.MOUSE_RELEASED;
        case MOUSE_RELEASED : return BwdEventType.MOUSE_PRESSED;
        //
        case MOUSE_ENTERED_CLIENT : return BwdEventType.MOUSE_EXITED_CLIENT;
        case MOUSE_EXITED_CLIENT : return BwdEventType.MOUSE_ENTERED_CLIENT;
        default:
            return null;
        }
    }
}
