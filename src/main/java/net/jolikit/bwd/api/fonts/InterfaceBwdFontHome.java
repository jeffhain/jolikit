/*
 * Copyright 2019-2020 Jeff Hain
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package net.jolikit.bwd.api.fonts;

import java.util.List;
import java.util.SortedSet;

/**
 * Interface for BWD fonts home, which allows to load and create fonts.
 * 
 * Font loading:
 * Loading a font means making its kind appear in the set of loaded font kinds,
 * and making it possible to create size-specific variants of it using
 * newFontXxx(...) methods.
 * There is no unloading method for specific fonts, because some libraries
 * might not support it.
 * When loading a font, if it causes a re-load due to the newly loaded font
 * having the same kind as another previously loaded font, some libraries
 * (such as SWT) might not provide a way to know which kind of font was
 * re-loaded, and to avoid any issue we would need to forcibly dispose all
 * current disposable fonts and default font, which would be impractical.
 * As a result, there is no method to load or re-load fonts after initial
 * fonts load, and we stick to a single bulk font loading method,
 * which must load both system fonts and the ones specified as arguments
 * ("user fonts"), and can only be called once.
 * 
 * Min/max font size:
 * When creating a font, if specifying a too small or too large font size,
 * some libraries just return some default font, without even telling you
 * that's not the font you asked for (how disrespectful!), or just blow up,
 * which is more appropriate but still annoying.
 * This API therefore defines methods to query a safe range for font sizes.
 * The safe range might depend on the backing library but also on the font,
 * but to keep things simple these methods don't depend on the font kind:
 * bindings should just return a range tight enough to be valid for fonts
 * that are loaded, or not load fonts which would cause the actual safe range
 * to shrink too much.
 * 
 * Vertical fonts:
 * Some fonts start with at sign ('@'), which indicates that they have vertical
 * capabilities, as said in the following discussion (2002/01/24):
 * - Question:
 *   "I've got some problems with Arial Unicode MS and MS Mincho. If I use
 *   one of these fonts, I see "@Arial Unicode MS" or "@MS Mincho" (...)"
 * - Answer:
 *   "The "at-font" or @font signifies the font can do vertical writing."
 *   (https://groups.google.com/forum/#!topic/microsoft.public.word.printingfonts/A37kwlfBtdY)
 * Also, for vertical fonts, advance is a vertical measure, cf.
 * "http://freetype.sourceforge.net/freetype2/docs/tutorial/step2.html".
 * Since there is usually no programmatic way of knowing whether a font is
 * horizontal or vertical, and since horizontal fonts already allow for
 * vertical drawing character by character, to keep things simple and
 * consistent we decide that vertical flavors of fonts, if generated by the
 * backing library (some do, some don't), must be ignored at load time.
 * 
 * Locale:
 * In some libraries, font objects behave differently depending on some "locale"
 * (as java.util.Locale), as a more or less static configuration (!!!),
 * or are subject to other "locale" related interferences.
 * However, we don't want to pollute this API with such an annoying concept,
 * and want to stick to the idea of a font being the one and only thing that
 * defines what glyph must correspond to a given code point.
 * If a "locale" ever needs to be configured, that has to be done in binding
 * implementation's specific configuration.
 */
public interface InterfaceBwdFontHome {
    
    /*
     * Not providing a method returning instances of disposable fonts,
     * because for a same BwdFontId, we would need to return as many
     * instances as created with newFontXxx(...) methods,
     * which would be confusing.
     */
    
    /*
     * Loading.
     */
    
    /**
     * If one of the specified font files could not be loaded,
     * rather than throwing (which could be done after loading
     * all possible files, since this method can't be called twice
     * for more loading), we prefer to complete normally and
     * return the list of font files that could be loaded,
     * for two reasons:
     * First, to allow the user to simply provide a lot of font files
     * and do best effort loading, rather than requiring the user
     * to figure out which font files are supported before figuring
     * out an acceptable list.
     * Second, to allow the user to easily figure out which font files
     * are not supported.
     * This method can of course still throw in case of internal error,
     * not related to font format issue.
     * 
     * This method must at least be able to read supported font types
     * from simple files, but it is allowed to also be able to dive into
     * zip archives or load fonts from network (with an URL) or from memory
     * or whatever.
     * 
     * When multiple fonts are loaded, and the last loaded one has the same
     * font kind as a previously loaded one, if the backing library also
     * considers that they are a same font then disposing the previous one
     * would also dispose the new one.
     * On the other hand, it should always be safe to consider that,
     * for a same font kind, the last loaded backing font is the one
     * to use for this font kind.
     * As a result, for a same font kind, we decide that the last loaded
     * backing font must be the one to use.
     * 
     * This method should first load system fonts, and then user fonts,
     * to allow user to override system fonts if possible.
     * 
     * @param userFontFilePathList List of user font files to load fonts from,
     *        in the order they appear in this list. Can be null or empty.
     * @return An immutable set of user font files that knowingly
     *         could be loaded (whether or not others overloaded them).
     * @throws NullPointerException if userFontFilePathList is not null and one
     *         of its elements is null.
     * @throws IllegalStateException if this home has been disposed.
     */
    public SortedSet<String> loadSystemAndUserFonts(List<String> userFontFilePathList);
    
    /*
     * 
     */
    
    /**
     * The returned collection must remain available after call
     * to dispose().
     * 
     * If called before fonts load, must return an empty set.
     * 
     * Note that some font kinds might be absent from this set
     * despite the corresponding font being properly loaded,
     * when using libraries that don't provide a way to know
     * which font was loaded when it replaces an already loaded
     * font of same kind, hence the word "knowingly".
     * 
     * @return An immutable set of knowingly loaded fonts kinds.
     */
    public SortedSet<BwdFontKind> getLoadedFontKindSet();
    
    /**
     * The returned collection must remain available after call
     * to dispose().
     * 
     * If called before fonts load, must return an empty set.
     * 
     * Allows to only consider font kinds of system fonts,
     * whether or not user fonts of same kind were loaded.
     * 
     * @return An immutable set of loaded system fonts kinds.
     */
    public SortedSet<BwdFontKind> getLoadedSystemFontKindSet();
    
    /**
     * The returned collection must remain available after call
     * to dispose().
     * 
     * If called before fonts load, must return an empty set.
     * 
     * Allows to only consider font kinds of user fonts,
     * whether or not system fonts of same kind were loaded.
     * 
     * Note that some font kinds might be absent from this set
     * despite the corresponding font being properly loaded,
     * when using libraries that don't provide a way to know
     * which font was loaded when it replaces an already loaded
     * font of same kind, hence the word "knowingly".
     * 
     * @return An immutable set of knowingly loaded user fonts kinds.
     */
    public SortedSet<BwdFontKind> getLoadedUserFontKindSet();
    
    /**
     * This method makes basic code much easier to write.
     * 
     * @return A default font, suitable for actual usage,
     *         i.e. not with a size of 1.
     * @throws IllegalStateException if the default font has not yet been created,
     *         i.e. if fonts loading has not yet been done.
     */
    public InterfaceBwdFont getDefaultFont();

    /*
     * 
     */
    
    /**
     * @return Min allowed font size. Must be >= 1.
     */
    public int getMinFontSize();

    /**
     * Even if the backing library seem to handle huge values well,
     * it's a good idea to just stop at Short.MAX_VALUE,
     * to avoid overflows in computations and memory issues.
     * 
     * @return Max allowed font size. Must be >= getMinFontSize().
     */
    public int getMaxFontSize();

    /*
     * 
     */
    
    /**
     * Uses default font kind.
     * Equivalent to newFontWithSize(home.getDefaultFont().kind(), fontSize).
     * 
     * @param fontSize Size of the font to create, in pixels.
     * @return A new font with default font kind and the specified size.
     * @throws IllegalArgumentException if the specified font size is out of
     *         [getMinFontSize(),getMaxFontSize()] range.
     * @throws IllegalStateException if this home has been disposed.
     */
    public InterfaceBwdFont newFontWithSize(int fontSize);
    
    /**
     * Uses default font kind.
     * Equivalent to newFontWithClosestHeight(home.getDefaultFont().kind(), targetFontHeight).
     * 
     * @param targetFontHeight Must be >= 1.
     * @return A new font with height closest to the specified target height.
     * @throws IllegalArgumentException if the specified target font height is
     *         inferior or equal to zero.
     * @throws IllegalStateException if this home has been disposed.
     */
    public InterfaceBwdFont newFontWithClosestHeight(int targetFontHeight);
    
    /**
     * Uses default font kind.
     * Equivalent to newFontWithFloorElseClosestHeight(home.getDefaultFont().kind(), targetFontHeight).
     * 
     * @param targetFontHeight Must be >= 1.
     * @return A new font with height closest to the specified target height.
     * @throws IllegalArgumentException if the specified target font height is
     *         inferior or equal to zero.
     * @throws IllegalStateException if this home has been disposed.
     */
    public InterfaceBwdFont newFontWithFloorElseClosestHeight(int targetFontHeight);
    
    /**
     * Uses default font kind.
     * Equivalent to newFontWithCeilingElseClosestHeight(home.getDefaultFont().kind(), targetFontHeight).
     * 
     * @param targetFontHeight Must be >= 1.
     * @return A new font with height closest and inferior or equal to the
     *         specified target height, or only closest if no such font could
     *         be computed.
     * @throws IllegalArgumentException if the specified target font height is
     *         inferior or equal to zero.
     * @throws IllegalStateException if this home has been disposed.
     */
    public InterfaceBwdFont newFontWithCeilingElseClosestHeight(int targetFontHeight);
    
    /*
     * 
     */
    
    /**
     * Depending on the backing library, this method might actually
     * load a font from a file each time, so don't expect it to be always fast,
     * and try to reuse your fonts instead of creating and disposing them
     * frantically.
     * 
     * If the backing library can't create a font of height corresponding
     * to the specified size, it must create the largest possible font
     * inferior to it (floor font), if possible, else the smallest font
     * it can return (as superior best effort).
     * 
     * To create a font with given height (which better represents the height
     * it actually occupies, than its size) or close to it, you might strongly
     * want to use one of newFontWithXxxHeight(...) methods.
     * 
     * @param fontKind Identifies the kind of font to create (i.e. all but size).
     *        Must be the kind of a loaded font.
     * @param fontSize Size of the font to create, in pixels.
     * @return A new font with the specified kind and size.
     * @throws NullPointerException if the specified font kind is null.
     * @throws IllegalArgumentException if no font with the specified kind
     *         has been loaded, or if the specified font size is out of
     *         [getMinFontSize(),getMaxFontSize()] range.
     * @throws IllegalStateException if this home has been disposed.
     */
    public InterfaceBwdFont newFontWithSize(BwdFontKind fontKind, int fontSize);

    /**
     * Convenience method, typically built on top of newFontWithSize(...).
     * 
     * Closest font is computed not with absolute error (|a-b|),
     * but with relative error (|a-b|/max(|a|,|b|)), which is
     * more visually intuitive.
     * 
     * @param fontKind Identifies the kind of font to create (i.e. all but size).
     *        Must be the kind of a loaded font.
     * @param targetFontHeight Must be >= 1.
     * @return A new font with height closest to the specified target height.
     * @throws NullPointerException if the specified font kind is null.
     * @throws IllegalArgumentException if no font with the specified kind
     *         has been loaded, or if the specified target font height is
     *         inferior or equal to zero.
     * @throws IllegalStateException if this home has been disposed.
     */
    public InterfaceBwdFont newFontWithClosestHeight(BwdFontKind fontKind, int targetFontHeight);
    
    /**
     * Convenience method, typically built on top of newFontWithSize(...).
     * 
     * @param fontKind Identifies the kind of font to create (i.e. all but size).
     *        Must be the kind of a loaded font.
     * @param targetFontHeight Must be >= 1.
     * @return A new font with height closest and inferior or equal to the
     *         specified target height, or only closest if no such font could
     *         be computed.
     * @throws NullPointerException if the specified font kind is null.
     * @throws IllegalArgumentException if no font with the specified kind
     *         has been loaded, or if the specified target font height is
     *         inferior or equal to zero.
     * @throws IllegalStateException if this home has been disposed.
     */
    public InterfaceBwdFont newFontWithFloorElseClosestHeight(BwdFontKind fontKind, int targetFontHeight);
    
    /**
     * Convenience method, typically built on top of newFontWithSize(...).
     * 
     * @param fontKind Identifies the kind of font to create (i.e. all but size).
     *        Must be the kind of a loaded font.
     * @param targetFontHeight Must be >= 1.
     * @return A new font with height closest and superior or equal to the
     *         specified target height, or only closest if no such font could
     *         be computed.
     * @throws NullPointerException if the specified font kind is null.
     * @throws IllegalArgumentException if no font with the specified kind
     *         has been loaded, or if the specified target font height is
     *         inferior or equal to zero.
     * @throws IllegalStateException if this home has been disposed.
     */
    public InterfaceBwdFont newFontWithCeilingElseClosestHeight(BwdFontKind fontKind, int targetFontHeight);
    
    /*
     * 
     */

    /**
     * Disposes fonts created with newFontXxx(...) methods.
     * 
     * This font home is to be disposed, including default font
     * and eventual internal fonts, by binding implementation
     * on its shutdown, so we don't need to provide a destructive
     * dispose() method in this API, which would clutter it
     * and could be called accidentally.
     */
    public void disposeDisposableFonts();
}
