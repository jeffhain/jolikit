/*
 * Copyright 2024 Jeff Hain
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package net.jolikit.bwd.test.cases.visualtests;

import java.util.Collections;
import java.util.List;
import java.util.Map;
import java.util.SortedMap;
import java.util.TreeMap;

import net.jolikit.bwd.api.InterfaceBwdBinding;
import net.jolikit.bwd.api.InterfaceBwdHost;
import net.jolikit.bwd.api.events.BwdKeyEventPr;
import net.jolikit.bwd.api.events.BwdKeys;
import net.jolikit.bwd.api.events.BwdWindowEvent;
import net.jolikit.bwd.api.fonts.InterfaceBwdFont;
import net.jolikit.bwd.api.graphics.BwdColor;
import net.jolikit.bwd.api.graphics.GPoint;
import net.jolikit.bwd.api.graphics.GRect;
import net.jolikit.bwd.api.graphics.InterfaceBwdGraphics;
import net.jolikit.bwd.api.graphics.InterfaceBwdImage;
import net.jolikit.bwd.api.graphics.InterfaceBwdWritableImage;
import net.jolikit.bwd.impl.utils.basics.BindingCoordsUtils;
import net.jolikit.bwd.impl.utils.graphics.InterfaceScaledRectDrawer;
import net.jolikit.bwd.impl.utils.graphics.ScaledRectDrawerBicubic;
import net.jolikit.bwd.impl.utils.graphics.ScaledRectDrawerBicubicAwt;
import net.jolikit.bwd.impl.utils.graphics.ScaledRectDrawerBilinear;
import net.jolikit.bwd.impl.utils.graphics.ScaledRectDrawerBilinearAwt;
import net.jolikit.bwd.impl.utils.graphics.ScaledRectDrawerBoxsampled;
import net.jolikit.bwd.impl.utils.graphics.ScaledRectDrawerBoxsampledBicubic;
import net.jolikit.bwd.impl.utils.graphics.ScaledRectDrawerBoxsampledBilinear;
import net.jolikit.bwd.impl.utils.graphics.ScaledRectDrawerNearest;
import net.jolikit.bwd.impl.utils.graphics.ScaledRectDrawerNearestAwt;
import net.jolikit.bwd.test.utils.BwdTestResources;
import net.jolikit.bwd.test.utils.InterfaceBwdTestCase;

public class ImageScalingOnCliScale1BwdTestCase extends AbstractImageScalingBwdTestCase {

    //--------------------------------------------------------------------------
    // CONFIGURATION
    //--------------------------------------------------------------------------
    
    private static final int INTERNAL_PARALLELISM =
        Runtime.getRuntime().availableProcessors();
    
    private static final int TARGET_FONT_HEIGHT = 8;
    
    private static final int INFO_WIDTH = 135;
    
    private static final int IMG_OFFSET_X = INFO_WIDTH;
    private static final int IMG_OFFSET_Y = 0;
    
    private static final double IMG_RESIZE_FACTOR = 1.2;
    
    /*
     * Images not in file, but generated by this test.
     */
    
    private static final String IMG_ALPHA_CIRCLES = "GEN_ALPHA_CIRCLES";
    
    private static final String IMG_ALPHA_HOR_OVALS = "GEN_HOR_OVALS";
    
    private static final String IMG_ALPHA_VER_OVALS = "GEN_VER_OVALS";
    
    /*
     * 
     */
    
    private static final String[] IMG_FILE_PATH_ARR =
        new String[] {
            BwdTestResources.TEST_IMG_FILE_PATH_LOREM_PNG,
            BwdTestResources.TEST_IMG_FILE_PATH_LOREM_X4_PNG,
            //
            BwdTestResources.TEST_IMG_FILE_PATH_STRUCT_COLOR_PNG,
            //
            BwdTestResources.TEST_IMG_FILE_PATH_TIME_SQUARE_PNG,
            //
            BwdTestResources.TEST_IMG_FILE_PATH_TIME_SQUARE_ALPHA_PNG,
            BwdTestResources.TEST_IMG_FILE_PATH_TIME_SQUARE_ALPHA_COLUMNS_PNG,
            //
            IMG_ALPHA_CIRCLES,
            IMG_ALPHA_HOR_OVALS,
            IMG_ALPHA_VER_OVALS,
        };
    
    // Resized on first draw anyway.
    private static final int INITIAL_WIDTH = 100;
    private static final int INITIAL_HEIGHT = 100;
    private static final GPoint INITIAL_CLIENT_SPANS =
        GPoint.valueOf(INITIAL_WIDTH, INITIAL_HEIGHT);
    
    private static final double CLIENT_SIZE_RESET_DELAY_S = 0.1;
    
    //--------------------------------------------------------------------------
    // FIELDS
    //--------------------------------------------------------------------------
    
    private static final SortedMap<String,InterfaceScaledRectDrawer> DRAWER_BY_NAME;
    static {
        final SortedMap<String,InterfaceScaledRectDrawer> map = new TreeMap<>();
        map.put("1_NEAREST", new ScaledRectDrawerNearest());
        map.put("2_NEAREST_AWT", new ScaledRectDrawerNearestAwt());
        map.put("3_BOXSAMPLED", new ScaledRectDrawerBoxsampled());
        map.put("4_BOXSAMPLED_BILINEAR", new ScaledRectDrawerBoxsampledBilinear());
        map.put("5_BILINEAR", new ScaledRectDrawerBilinear());
        map.put("6_BILINEAR_AWT", new ScaledRectDrawerBilinearAwt());
        map.put("7_BOXSAMPLED_BICUBIC", new ScaledRectDrawerBoxsampledBicubic());
        map.put("8_BICUBIC", new ScaledRectDrawerBicubic());
        map.put("9_BICUBIC_AWT", new ScaledRectDrawerBicubicAwt());
        DRAWER_BY_NAME = Collections.unmodifiableSortedMap(map);
    }
    
    private InterfaceBwdFont font;
    
    private InterfaceBwdImage image;
    
    private int currentImageIndex = 0;
    private int currentImageScalingTypeIndex = 0;
    
    //--------------------------------------------------------------------------
    // PUBLIC METHODS
    //--------------------------------------------------------------------------

    public ImageScalingOnCliScale1BwdTestCase() {
    }

    public ImageScalingOnCliScale1BwdTestCase(InterfaceBwdBinding binding) {
        super(binding);
    }
    
    @Override
    public InterfaceBwdTestCase newTestCase(InterfaceBwdBinding binding) {
        return new ImageScalingOnCliScale1BwdTestCase(binding);
    }
    
    @Override
    public GPoint getInitialClientSpans() {
        return INITIAL_CLIENT_SPANS;
    }
    
    @Override
    public Integer getParallelizerParallelismElseNull() {
        /*
         * We use public parallelizer for AWT scalings.
         */
        return INTERNAL_PARALLELISM;
    }

    @Override
    public Integer getInternalParallelismElseNull() {
        return INTERNAL_PARALLELISM;
    }

    /*
     * Window events.
     */
    
    @Override
    public void onWindowShown(BwdWindowEvent event) {
        super.onWindowShown(event);
        
        this.tryResetClientSizeAfterDelay();
    }
    
    /*
     * Key events.
     */

    @Override
    public void onKeyPressed(BwdKeyEventPr event) {
        final int key = event.getKey();
        if (key == BwdKeys.UP) {
            if (event.isShiftDown()) {
                this.changeClientSize(true);
            } else {
                this.changeImageScalingType(true);
            }
        } else if (key == BwdKeys.DOWN) {
            if (event.isShiftDown()) {
                this.changeClientSize(false);
            } else {
                this.changeImageScalingType(false);
            }
        } else if (key == BwdKeys.LEFT) {
            this.changeImage(false);
        } else if (key == BwdKeys.RIGHT) {
            this.changeImage(true);
        } else if (key == BwdKeys.SPACE) {
            this.tryResetClientSize();
        }
    }
    
    //--------------------------------------------------------------------------
    // PROTECTED METHODS
    //--------------------------------------------------------------------------
    
    @Override
    protected List<GRect> paintClientImpl(
            InterfaceBwdGraphics g,
            GRect dirtyRect) {

        final GRect box = g.getBox();

        final InterfaceBwdBinding binding = this.getBinding();
        
        final Map.Entry<String, InterfaceScaledRectDrawer> entry =
            this.getDrawerEntry();
        final String algoName = entry.getKey();
        final InterfaceScaledRectDrawer drawer = entry.getValue();

        /*
         * 
         */
        
        g.setColor(BwdColor.GRAY);
        g.clearRect(box);
        
        final InterfaceBwdImage image = this.getOrCreateImage();
        final GRect imgRect = image.getRect();
        
        final GRect imgBox = box.withBordersDeltasElseEmpty(
            IMG_OFFSET_X,
            IMG_OFFSET_Y,
            0,
            0);
        
        final double dtS = this.drawScaledAndGetDrawDurationS(
            image,
            g,
            imgBox,
            drawer);
        
        /*
         * infos
         */
        
        {
            InterfaceBwdFont font = this.font;
            if (font == null) {
                font = binding.getFontHome().newFontWithClosestHeight(TARGET_FONT_HEIGHT);
                this.font = font;
            }
            final int lineHeight = font.metrics().height() + 1;
            
            g.setColor(BwdColor.BLACK);
            g.setFont(font);
            
            int tmpX = box.x();
            int tmpY = box.y();
            
            g.drawText(tmpX, tmpY, "scaling: " + algoName);
            tmpY += lineHeight;
            
            g.drawText(tmpX, tmpY, "xRatio: " + (imgBox.xSpan() / (float) imgRect.xSpan()));
            tmpY += lineHeight;
            g.drawText(tmpX, tmpY, "yRatio: " + (imgBox.ySpan() / (float) imgRect.ySpan()));
            tmpY += lineHeight;
            /*
             * NB: This measurement is meaningless for asynchronous pipelines
             * such as JavaFX.
             */
            g.drawText(tmpX, tmpY, "took " + (float) dtS + " s");
            tmpY += lineHeight;
            
            g.drawText(tmpX, tmpY, "(scaling type: up/down)");
            tmpY += lineHeight;
            g.drawText(tmpX, tmpY, "(image: left/right)");
            tmpY += lineHeight;
            g.drawText(tmpX, tmpY, "(scaled size: SHIFT + up/down)");
            tmpY += lineHeight;
            g.drawText(tmpX, tmpY, "(size reset: space)");
            tmpY += lineHeight;
        }
        
        /*
         * 
         */
        
        return null;
    }
    
    //--------------------------------------------------------------------------
    // PRIVATE METHODS
    //--------------------------------------------------------------------------

    private Map.Entry<String, InterfaceScaledRectDrawer> getDrawerEntry() {
        final Object[] ea = DRAWER_BY_NAME.entrySet().toArray();
        final Map.Entry<String, InterfaceScaledRectDrawer> e =
            (Map.Entry<String, InterfaceScaledRectDrawer>) ea[this.currentImageScalingTypeIndex];
        return e;
    }

    private InterfaceBwdImage getOrCreateImage() {
        InterfaceBwdImage image = this.image;
        if (image == null) {
            final String imagePath =
                IMG_FILE_PATH_ARR[this.currentImageIndex];
            if (IMG_ALPHA_CIRCLES.equals(imagePath)) {
                image = this.newAlphaCirclesImage();
            } else if (IMG_ALPHA_HOR_OVALS.equals(imagePath)) {
                image = this.newAlphaHorOvalsImage();
            } else if (IMG_ALPHA_VER_OVALS.equals(imagePath)) {
                image = this.newAlphaVerOvalsImage();
            } else {
                image = this.getBinding().newImage(imagePath);
            }
            this.image = image;
        }
        return image;
    }
    
    private InterfaceBwdImage newAlphaCirclesImage() {
        final int width = 400;
        final int height = 400;
        return this.newAlphaOvalsImage(width, height);
    }
    
    /**
     * For test when having large downscaling on X dimension
     * and large upscaling on Y dimension,
     * in which case BOXSAMPLED_XXX should shine.
     */
    private InterfaceBwdImage newAlphaHorOvalsImage() {
        final int width = 800;
        final int height = 40;
        return this.newAlphaOvalsImage(width, height);
    }
    
    /**
     * For test when having large downscaling on Y dimension
     * and large upscaling on X dimension,
     * in which case BOXSAMPLED_XXX should shine.
     */
    private InterfaceBwdImage newAlphaVerOvalsImage() {
        final int width = 40;
        final int height = 800;
        return this.newAlphaOvalsImage(width, height);
    }
    
    private InterfaceBwdImage newAlphaOvalsImage(int width, int height) {
        final InterfaceBwdWritableImage wi =
            this.getBinding().newWritableImage(width, height);
        final InterfaceBwdGraphics wig = wi.getGraphics();
        final GRect box = wig.getBox();
        
        wig.setColor(BwdColor.BLACK);
        final int maxSpan = Math.max(width, height);
        final int rMax = (int) (Math.sqrt(2.0) * maxSpan);
        final int rxStep = 4 * Math.max(1, (int) Math.ceil(width / (double) height));
        final int ryStep = 4 * Math.max(1, (int) Math.ceil(height / (double) width));
        for (int rx = 0, ry = 0; (rx <= rMax) && (ry <= rMax); rx += rxStep, ry += ryStep) {
            wig.drawOval(
                box.xMid() - rx,
                box.yMid() - ry,
                2 * rx + 1,
                2 * ry + 1);
        }
        
        return wi;
    }
    
    private void tryResetClientSizeAfterDelay() {
        this.getBinding().getUiThreadScheduler().executeAfterS(new Runnable() {
            @Override
            public void run() {
                tryResetClientSize();
            }
        }, CLIENT_SIZE_RESET_DELAY_S);
    }
    
    /**
     * Useful when window is not decorated.
     */
    private void tryResetClientSize() {
        final InterfaceBwdHost host = this.getHost();
        GRect clientBounds = host.getClientBounds();
        if (clientBounds.isEmpty()) {
            // Can't.
            // Will try again later. Useful on Mac where things are pushy.
            tryResetClientSizeAfterDelay();
            return;
        }
        
        final GRect imgRect = this.getOrCreateImage().getRect();
        
        clientBounds = GRect.valueOf(
            clientBounds.xMid() - imgRect.xSpan() / 2 - IMG_OFFSET_X,
            clientBounds.yMid() - imgRect.ySpan() / 2 - IMG_OFFSET_Y,
            imgRect.xSpan() + IMG_OFFSET_X,
            imgRect.ySpan() + IMG_OFFSET_Y);
        
        host.setClientBoundsSmart(clientBounds);
        
        host.ensurePendingClientPainting();
    }
    
    /**
     * Useful when window is not decorated.
     */
    private void changeClientSize(boolean incrElseDecr) {
        final InterfaceBwdHost host = this.getHost();
        GRect clientBounds = host.getClientBounds();
        if (clientBounds.isEmpty()) {
            // Can't.
            return;
        }
        
        final double refFactor = IMG_RESIZE_FACTOR;
        final double factor = (incrElseDecr ? refFactor : 1.0/refFactor);
        final int newXSpan = IMG_OFFSET_X +
            BindingCoordsUtils.roundToInt(
                Math.max(0, clientBounds.xSpan() - IMG_OFFSET_X) * factor);
        final int newYSpan = IMG_OFFSET_Y +
            BindingCoordsUtils.roundToInt(
                Math.max(0, clientBounds.ySpan() - IMG_OFFSET_Y) * factor);
        clientBounds = GRect.valueOf(
            clientBounds.xMid() - newXSpan / 2,
            clientBounds.yMid() - newYSpan / 2,
            newXSpan,
            newYSpan);
        
        host.setClientBoundsSmart(clientBounds);
        
        host.ensurePendingClientPainting();
    }
    
    private void changeImage(boolean nextElsePrev) {
        final int delta = (nextElsePrev ? 1 : -1);
        this.currentImageIndex =
            ((this.currentImageIndex + delta + IMG_FILE_PATH_ARR.length)
                % IMG_FILE_PATH_ARR.length);
        
        InterfaceBwdImage image = this.image;
        if (image != null) {
            image.dispose();
            this.image = null;
        }
        
        final InterfaceBwdHost host = this.getHost();
        host.ensurePendingClientPainting();
    }
    
    private void changeImageScalingType(boolean nextElsePrev) {
        final int delta = (nextElsePrev ? 1 : -1);
        this.currentImageScalingTypeIndex =
            ((this.currentImageScalingTypeIndex
                + delta + DRAWER_BY_NAME.size())
                % DRAWER_BY_NAME.size());
        
        final InterfaceBwdHost host = this.getHost();
        host.ensurePendingClientPainting();
    }
}
