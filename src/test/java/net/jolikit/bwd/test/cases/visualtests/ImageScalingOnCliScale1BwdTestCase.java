/*
 * Copyright 2024 Jeff Hain
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package net.jolikit.bwd.test.cases.visualtests;

import java.util.Collections;
import java.util.List;
import java.util.Map;
import java.util.SortedMap;
import java.util.TreeMap;

import net.jolikit.bwd.api.InterfaceBwdBinding;
import net.jolikit.bwd.api.InterfaceBwdHost;
import net.jolikit.bwd.api.events.BwdMouseButtons;
import net.jolikit.bwd.api.events.BwdMouseEvent;
import net.jolikit.bwd.api.events.BwdWheelEvent;
import net.jolikit.bwd.api.events.BwdWindowEvent;
import net.jolikit.bwd.api.fonts.InterfaceBwdFont;
import net.jolikit.bwd.api.graphics.BwdColor;
import net.jolikit.bwd.api.graphics.BwdScalingType;
import net.jolikit.bwd.api.graphics.GPoint;
import net.jolikit.bwd.api.graphics.GRect;
import net.jolikit.bwd.api.graphics.GRotation;
import net.jolikit.bwd.api.graphics.GTransform;
import net.jolikit.bwd.api.graphics.InterfaceBwdGraphics;
import net.jolikit.bwd.api.graphics.InterfaceBwdImage;
import net.jolikit.bwd.api.graphics.InterfaceBwdWritableImage;
import net.jolikit.bwd.impl.utils.basics.BindingCoordsUtils;
import net.jolikit.bwd.impl.utils.graphics.IntArrCopyRowDrawer;
import net.jolikit.bwd.impl.utils.graphics.IntArrHolder;
import net.jolikit.bwd.impl.utils.graphics.IntArrSrcPixels;
import net.jolikit.bwd.impl.utils.graphics.InterfaceColorTypeHelper;
import net.jolikit.bwd.impl.utils.graphics.InterfaceScaledRectDrawer;
import net.jolikit.bwd.impl.utils.graphics.PremulArgbHelper;
import net.jolikit.bwd.impl.utils.graphics.ScaledRectDrawerBicubic;
import net.jolikit.bwd.impl.utils.graphics.ScaledRectDrawerBicubicAwt;
import net.jolikit.bwd.impl.utils.graphics.ScaledRectDrawerBilinear;
import net.jolikit.bwd.impl.utils.graphics.ScaledRectDrawerBilinearAwt;
import net.jolikit.bwd.impl.utils.graphics.ScaledRectDrawerNearest;
import net.jolikit.bwd.impl.utils.graphics.ScaledRectDrawerNearestAwt;
import net.jolikit.bwd.test.cases.utils.AbstractBwdTestCase;
import net.jolikit.bwd.test.utils.BwdTestResources;
import net.jolikit.bwd.test.utils.InterfaceBwdTestCase;
import net.jolikit.time.TimeUtils;

public class ImageScalingOnCliScale1BwdTestCase extends AbstractBwdTestCase {

    //--------------------------------------------------------------------------
    // CONFIGURATION
    //--------------------------------------------------------------------------
    
    private static final int INTERNAL_PARALLELISM =
        Runtime.getRuntime().availableProcessors();
    
    private static final int TARGET_FONT_HEIGHT = 8;
    
    private static final int INFO_WIDTH = 135;
    private static final int INFO_HEIGHT = 75;
    
    private static final double CLIENT_RESIZE_FACTOR = 1.2;
    
    /**
     * Image not in file, but generated by this test.
     */
    private static final String IMG_ALPHA_CIRCLES = "ALPHA_BANDS";
    private static final String[] IMG_FILE_PATH_ARR =
        new String[] {
            BwdTestResources.TEST_IMG_FILE_PATH_LOREM_PNG,
            BwdTestResources.TEST_IMG_FILE_PATH_STRUCT_COLOR_PNG,
            BwdTestResources.TEST_IMG_FILE_PATH_TIME_SQUARE_PNG,
            //
            BwdTestResources.TEST_IMG_FILE_PATH_TIME_SQUARE_ALPHA_PNG,
            BwdTestResources.TEST_IMG_FILE_PATH_TIME_SQUARE_ALPHA_LINES_PNG,
            IMG_ALPHA_CIRCLES,
        };
    
    // Resized on first draw anyway.
    private static final int INITIAL_WIDTH = 100;
    private static final int INITIAL_HEIGHT = 100;
    private static final GPoint INITIAL_CLIENT_SPANS =
        GPoint.valueOf(INITIAL_WIDTH, INITIAL_HEIGHT);
    
    private static final double FIRST_DRAW_DELAY_S = 0.1;
    
    //--------------------------------------------------------------------------
    // FIELDS
    //--------------------------------------------------------------------------
    
    private static final SortedMap<String,InterfaceScaledRectDrawer> DRAWER_BY_NAME;
    static {
        final SortedMap<String,InterfaceScaledRectDrawer> map = new TreeMap<>();
        map.put("1_NEAREST", new ScaledRectDrawerNearest());
        map.put("2_NEAREST_AWT", new ScaledRectDrawerNearestAwt());
        map.put("3_BILINEAR", new ScaledRectDrawerBilinear());
        map.put("4_BILINEAR_AWT", new ScaledRectDrawerBilinearAwt());
        map.put("5_BICUBIC", new ScaledRectDrawerBicubic());
        map.put("6_BICUBIC_AWT", new ScaledRectDrawerBicubicAwt());
        DRAWER_BY_NAME = Collections.unmodifiableSortedMap(map);
    }
    
    private InterfaceBwdFont font;
    
    private InterfaceBwdImage image;
    
    private int currentImageIndex = 0;
    private int currentImageScalingTypeIndex = 0;
    
    /*
     * temps
     */
    
    /**
     * Need temporary array for srcPixels, because graphics
     * are not thread-safe, so can't read pixels from them
     * concurrently.
     */
    private final IntArrHolder tmpSrcArr = new IntArrHolder();
    
    /**
     * Need temporary array for dstRowDrawer, because graphics
     * are not thread-safe, so can't write pixels to them
     * concurrently.
     */
    private final IntArrHolder tmpDstArr = new IntArrHolder();
    
    //--------------------------------------------------------------------------
    // PUBLIC METHODS
    //--------------------------------------------------------------------------

    public ImageScalingOnCliScale1BwdTestCase() {
    }

    public ImageScalingOnCliScale1BwdTestCase(InterfaceBwdBinding binding) {
        super(binding);
    }
    
    @Override
    public InterfaceBwdTestCase newTestCase(InterfaceBwdBinding binding) {
        return new ImageScalingOnCliScale1BwdTestCase(binding);
    }
    
    @Override
    public GPoint getInitialClientSpans() {
        return INITIAL_CLIENT_SPANS;
    }
    
    @Override
    public Integer getParallelizerParallelismElseNull() {
        /*
         * We use public parallelizer for AWT scalings.
         */
        return INTERNAL_PARALLELISM;
    }

    @Override
    public Integer getInternalParallelismElseNull() {
        return INTERNAL_PARALLELISM;
    }

    /*
     * Window events.
     */
    
    @Override
    public void onWindowShown(BwdWindowEvent event) {
        super.onWindowShown(event);
        
        this.getBinding().getUiThreadScheduler().executeAfterS(new Runnable() {
            @Override
            public void run() {
                trySetClientSizeToCurrentImageSize();
            }
        }, FIRST_DRAW_DELAY_S);
    }
    
    /*
     * Mouse events.
     */

    @Override
    public void onMousePressed(BwdMouseEvent event) {
        super.onMousePressed(event);
        
        if (event.isShiftDown()) {
            if (event.getButton() == BwdMouseButtons.PRIMARY) {
                this.changeClientSize(true);
            } else if (event.getButton() == BwdMouseButtons.SECONDARY) {
                this.changeClientSize(false);
            }
        } else {
            if (event.isControlDown()
                && (event.getButton() == BwdMouseButtons.PRIMARY)) {
                this.trySetClientSizeToCurrentImageSize();
            }
        }
    }

    @Override
    public void onWheelRolled(BwdWheelEvent event) {
        super.onWheelRolled(event);
        
        if (event.isShiftDown()) {
            if (event.yRoll() < 0) {
                this.changeImage(false);
            } else if (event.yRoll() > 0) {
                this.changeImage(true);
            }
        } else {
            if (event.yRoll() < 0) {
                this.changeImageScalingType(false);
            } else if (event.yRoll() > 0) {
                this.changeImageScalingType(true);
            }
        }
    }

    //--------------------------------------------------------------------------
    // PROTECTED METHODS
    //--------------------------------------------------------------------------
    
    /**
     * @return False by default.
     */
    protected boolean mustClipScaling() {
        return false;
    }
    
    /**
     * @return False by default.
     */
    protected boolean mustDrawScaledOnWritableImage() {
        return false;
    }
    
    @Override
    protected List<GRect> paintClientImpl(
            InterfaceBwdGraphics g,
            GRect dirtyRect) {

        final GRect box = g.getBox();

        final InterfaceBwdBinding binding = this.getBinding();
        
        final Map.Entry<String, InterfaceScaledRectDrawer> entry =
            this.getDrawerEntry();
        final String algoName = entry.getKey();
        final InterfaceScaledRectDrawer drawer = entry.getValue();

        /*
         * First, clearing background with white,
         * in case of alpha image.
         */
        
        g.setColor(BwdColor.WHITE);
        g.clearRect(box);
        
        /*
         * 
         */
        
        final boolean mustClipScaling = this.mustClipScaling();
        
        final InterfaceBwdImage image = this.getOrCreateImage();
        final GRect imgRect = image.getRect();

        final boolean mustScaleOnWi = this.mustDrawScaledOnWritableImage();
        
        InterfaceBwdWritableImage wi = null;
        InterfaceBwdGraphics gForScaling;
        if (mustScaleOnWi) {
            wi = this.getBinding().newWritableImage(
                box.xSpan(),
                box.ySpan());
            gForScaling = wi.getGraphics();
        } else {
            gForScaling = g;
        }
        
        if (mustClipScaling) {
            final int spanDiv = 8;
            gForScaling.addClipInBase(box.withBordersDeltasElseEmpty(
                box.xSpan() / spanDiv,
                box.ySpan() / spanDiv,
                -box.xSpan() / spanDiv,
                -box.ySpan() / spanDiv));
        }
        
        final BwdScalingType scalingType;
        if (drawer instanceof ScaledRectDrawerNearest) {
            scalingType = BwdScalingType.NEAREST;
        } else if (drawer instanceof ScaledRectDrawerBilinear) {
            scalingType = BwdScalingType.BILINEAR;
        } else if (drawer instanceof ScaledRectDrawerBicubic) {
            scalingType = BwdScalingType.BICUBIC;
        } else {
            scalingType = null;
        }
        
        final double dtS;
        if (scalingType != null) {
            gForScaling.setImageScalingType(scalingType);
            final long t1Ns = System.nanoTime();
            gForScaling.drawImage(box, image);
            final long t2Ns = System.nanoTime();
            dtS = TimeUtils.nsToS(t2Ns - t1Ns);
        } else {
            /*
             * Alien scaling type: will run the algo
             * on int arrays of pixels. 
             */
            final GRect srcRect = imgRect;
            final GRect dstRect = box;
            
            // Our graphics and scalings use premul,
            // so doing the same for AWT scaling to be fair.
            final InterfaceColorTypeHelper colorTypeHelper =
                PremulArgbHelper.getInstance();
            
            final IntArrSrcPixels srcPixels = new IntArrSrcPixels();
            {
                final int[] srcPixelsArr = this.tmpSrcArr.getArr(imgRect.area());
                final int sw = imgRect.xSpan();
                final int sh = imgRect.ySpan();
                for (int y = 0; y < sh; y++) {
                    for (int x = 0; x < sw; x++) {
                        final int srcNonPremulArgb32 = image.getArgb32At(x, y);
                        final int srcColor32 =
                            colorTypeHelper.asTypeFromNonPremul32(
                                srcNonPremulArgb32);
                        srcPixelsArr[y * sw + x] = srcColor32;
                    }
                }
                srcPixels.configure(sw, sh, srcPixelsArr, sw);
            }
            final GRect dstClip = dstRect;
            final GRect dstRectClipped = dstRect.intersected(dstClip);
            final int dw = dstRectClipped.xSpan();
            final int dh = dstRectClipped.ySpan();
            //
            // Don't need to zeroize,
            // because using IntArrCopyRowDrawer.
            final int[] dstArr = this.tmpDstArr.getArr(dstRectClipped.area());
            final IntArrCopyRowDrawer dstRowDrawer = new IntArrCopyRowDrawer();
            // We want (dstRect.x(),dstRect.y())
            // to be itDstColor32Arr[0].
            final GTransform transformArrToDst =
                GTransform.valueOf(
                    GRotation.ROT_0,
                    -dstRect.x(),
                    -dstRect.y());
            dstRowDrawer.configure(
                transformArrToDst,
                dstArr,
                dw);
            //
            final long t1Ns = System.nanoTime();
            drawer.drawScaledRect(
                binding.getParallelizer(),
                colorTypeHelper,
                srcPixels,
                srcRect,
                dstRect,
                dstClip,
                dstRowDrawer);
            final long t2Ns = System.nanoTime();
            dtS = TimeUtils.nsToS(t2Ns - t1Ns);
            //
            for (int j = 0; j < dh; j++) {
                final int y = dstRect.y() + j;
                for (int i = 0; i < dw; i++) {
                    final int x = dstRect.x() + i;
                    final int dstColor32 = dstArr[j * dw + i];
                    final int dstNonPremulArgb32 =
                        colorTypeHelper.asNonPremul32FromType(dstColor32);
                    gForScaling.setArgb32(dstNonPremulArgb32);
                    gForScaling.drawPoint(x, y);
                }
            }
        }
        
        if (mustScaleOnWi) {
            g.drawImage(0, 0, wi);
            
            wi.dispose();
            // No longer usable.
            wi = null;
            gForScaling = null;
        } else {
            if (mustClipScaling) {
                g.removeLastAddedClip();
            }
        }
        
        /*
         * infos
         */
        
        final GRect textRect =
            GRect.valueOf(0, 0, INFO_WIDTH, INFO_HEIGHT);
        {
            // Clear text BG.
            g.setColor(BwdColor.GRAY);
            g.clearRect(textRect);
        }
        {
            InterfaceBwdFont font = this.font;
            if (font == null) {
                font = binding.getFontHome().newFontWithClosestHeight(TARGET_FONT_HEIGHT);
                this.font = font;
            }
            final int lineHeight = font.metrics().height() + 1;
            
            g.setColor(BwdColor.BLACK);
            g.setFont(font);
            
            int tmpX = box.x();
            int tmpY = box.y();
            
            g.drawText(tmpX, tmpY, "scaling: " + algoName);
            tmpY += lineHeight;
            
            g.drawText(tmpX, tmpY, "xRatio: " + (box.xSpan() / (float) imgRect.xSpan()));
            tmpY += lineHeight;
            g.drawText(tmpX, tmpY, "yRatio: " + (box.ySpan() / (float) imgRect.ySpan()));
            tmpY += lineHeight;
            /*
             * NB: This measurement is meaningless for asynchronous pipelines
             * such as JavaFX.
             */
            g.drawText(tmpX, tmpY, "took " + (float) dtS + " s");
            tmpY += lineHeight;
            
            g.drawText(tmpX, tmpY, "(image scaling: wheel)");
            tmpY += lineHeight;
            g.drawText(tmpX, tmpY, "(image: SHIFT + wheel)");
            tmpY += lineHeight;
            g.drawText(tmpX, tmpY, "(client size: SHIFT + L/R-click)");
            tmpY += lineHeight;
            g.drawText(tmpX, tmpY, "(client reset: CTRL + L-click)");
            tmpY += lineHeight;
        }
        
        /*
         * 
         */
        
        return null;
    }
    
    //--------------------------------------------------------------------------
    // PRIVATE METHODS
    //--------------------------------------------------------------------------

    private Map.Entry<String, InterfaceScaledRectDrawer> getDrawerEntry() {
        final Object[] ea = DRAWER_BY_NAME.entrySet().toArray();
        final Map.Entry<String, InterfaceScaledRectDrawer> e =
            (Map.Entry<String, InterfaceScaledRectDrawer>) ea[this.currentImageScalingTypeIndex];
        return e;
    }

    private InterfaceBwdImage getOrCreateImage() {
        InterfaceBwdImage image = this.image;
        if (image == null) {
            final String imagePath =
                IMG_FILE_PATH_ARR[this.currentImageIndex];
            if (IMG_ALPHA_CIRCLES.equals(imagePath)) {
                image = this.newAlphaCirclesImage();
            } else {
                image = this.getBinding().newImage(imagePath);
            }
            this.image = image;
        }
        return image;
    }
    
    private InterfaceBwdImage newAlphaCirclesImage() {
        final int width = 500;
        final int height = 500;
        final InterfaceBwdWritableImage wi =
            this.getBinding().newWritableImage(width, height);
        final InterfaceBwdGraphics wig = wi.getGraphics();
        wig.setColor(BwdColor.TRANSPARENT);
        final GRect box = wig.getBox();
        wig.fillRect(box);
        {
            final InterfaceBwdWritableImage wi2 =
                this.getBinding().newWritableImage(width, height);
            final InterfaceBwdGraphics wig2 = wi2.getGraphics();
            wig2.setColor(BwdColor.TRANSPARENT);
            wig2.fillRect(wig2.getBox());
            wig2.setColor(BwdColor.BLACK);
            final int rMax =
                (int) (Math.sqrt(2.0) * Math.max(width, height));
            for (int r = 0; r <= rMax; r += 4) {
                wig2.drawOval(
                    box.xMid() - r,
                    box.yMid() - r,
                    2 * r + 1,
                    2 * r + 1);
            }
            wig.drawImage(box, wi2);
            wi2.dispose();
        }
        return wi;
    }
    
    /**
     * Useful when window is not decorated.
     */
    private void trySetClientSizeToCurrentImageSize() {
        final InterfaceBwdHost host = this.getHost();
        GRect clientBounds = host.getClientBounds();
        if (clientBounds.isEmpty()) {
            // Can't.
            return;
        }
        
        final GRect imgRect = this.getOrCreateImage().getRect();
        
        clientBounds = GRect.valueOf(
            clientBounds.xMid() - imgRect.xSpan() / 2,
            clientBounds.yMid() - imgRect.ySpan() / 2,
            imgRect.xSpan(),
            imgRect.ySpan());
        
        host.setClientBoundsSmart(clientBounds);
        
        host.ensurePendingClientPainting();
    }
    
    /**
     * Useful when window is not decorated.
     */
    private void changeClientSize(boolean incrElseDecr) {
        final InterfaceBwdHost host = this.getHost();
        GRect clientBounds = host.getClientBounds();
        if (clientBounds.isEmpty()) {
            // Can't.
            return;
        }
        
        final double refFactor = CLIENT_RESIZE_FACTOR;
        final double factor = (incrElseDecr ? refFactor : 1.0/refFactor);
        final int newXSpan =
            BindingCoordsUtils.roundToInt(clientBounds.xSpan() * factor);
        final int newYSpan =
            BindingCoordsUtils.roundToInt(clientBounds.ySpan() * factor);
        clientBounds = GRect.valueOf(
            clientBounds.xMid() - newXSpan / 2,
            clientBounds.yMid() - newYSpan / 2,
            newXSpan,
            newYSpan);
        
        host.setClientBoundsSmart(clientBounds);
        
        host.ensurePendingClientPainting();
    }
    
    private void changeImage(boolean nextElsePrev) {
        final int delta = (nextElsePrev ? 1 : -1);
        this.currentImageIndex =
            ((this.currentImageIndex + delta + IMG_FILE_PATH_ARR.length)
                % IMG_FILE_PATH_ARR.length);
        
        InterfaceBwdImage image = this.image;
        if (image != null) {
            image.dispose();
            this.image = null;
        }
        
        final InterfaceBwdHost host = this.getHost();
        host.ensurePendingClientPainting();
    }
    
    private void changeImageScalingType(boolean nextElsePrev) {
        final int delta = (nextElsePrev ? 1 : -1);
        this.currentImageScalingTypeIndex =
            ((this.currentImageScalingTypeIndex
                + delta + DRAWER_BY_NAME.size())
                % DRAWER_BY_NAME.size());
        
        final InterfaceBwdHost host = this.getHost();
        host.ensurePendingClientPainting();
    }
}
