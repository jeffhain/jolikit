################################################################################
Jolikit X.X, XXXX/XX/XX

- Corrected a bug in HardScheduler, where workers were not being woken up
  after schedules removals due to cancellations (cancelPendingAsapSchedules(),
  cancelPendingTimedSchedules()) or drains (drainPendingAsapRunnablesInto(...),
  drainPendingTimedRunnablesInto(...)).
  This could cause shutdownNow(...) (which calls drain methods) to let worker
  threads wait, instead of figuring out shutdown state and die.
  Possible workarounds were to call interruptWorkers() after shutdownNow(...),
  or to call stopAccepting() and then drain or cancellation methods before
  calling shutdownNow(...).
   
- Scheduling redesign:

  - Removed the over-engineering of InterfaceSchedulable and
    InterfaceScheduling interfaces, which allowed schedulers to indicate to
    runnables their theoretical and actual execution times, and allowed
    runnables to ask the scheduler for re-schedules without going through
    scheduler's regular (interface-implementing) executeXxx(...) methods.
    In schedulers implementations, it caused complexities which were unnecessary
    (since these features can easily be added on top of regular runnables),
    and it did not allow to intercept (internal) re-schedules by simply
    overriding executeAtNs(...) method.
    Also, this caused calls to clock.getTimeNs() for each runnable execution,
    even when there were only ASAP schedules, and added a useless per-schedule
    memory overhead for users not caring about execution times or re-schedules.

  - In HardScheduler, instead of giving priority to timed schedules over
    ASAP schedules, which could cause ASAP schedules to never be executed
    in case of bursts of timed schedules for current time (or in the past),
    implemented fairness by adding a sequence number for ASAP schedules.
    Now, if an ASAP schedule and a timed schedule which time has come
    are to be executed, the one with the smallest sequence number is
    executed first.
    Note that this was already the behavior of SoftScheduler,
    so now these schedulers behave consistently.

  - Renamed AbstractSmartSchedulable into AbstractRepeatableRunnable,
    AbstractTask into AbstractRepeatableTask, and AbstractRepeatedProcess into
    AbstractProcess, and updated their javadoc to describe how they are related.
    For each of them, re-schedules are now done through a protected method that
    can be overridden, which allows for custom (and even unlawful) re-scheduling
    logics.
    For AbstractRepeatableRunnable and AbstractRepeatableTask instances,
    the theoretical time for a first timed schedule (when the state is pending)
    has now to be set (with setNextTheoreticalTimeNs(...)) before submitting
    to the scheduler, since it's no longer computed by the scheduler.
    If it's not set, it will be equal to actual time (which is fine for ASAP
    schedules, or if you don't care about it).

- BaseBwdBindingConfig : parallelizerParallelism set to 1 by default,
  instead of to available parallelism, for multi-threading not to hurt
  incognizant users.

- In AbstractBwdHost, runWindowEventLogicLoopOnPeriod(..) visibility was
  changed from package-private to protected.

- In AbstractBwdBinding, renamed onClosedEventFiringImpl(...) into
  onHostClosedEventFiringImpl(...). 

- AwtEventConverter : guards against spurious wheel events on Mac.

- Added finals for Java 7 (or less) source compatibility.

- Restored an actual parallelism for related test cases
  (config default had been changed to 1).

- Obsolete comments, log and tests upgrades in net.jolikit.time.sched packages.

################################################################################
Jolikit 0.1, 2019/05/22
################################################################################
